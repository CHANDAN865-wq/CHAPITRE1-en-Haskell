

---

# ğŸ“Œ Ã‰noncÃ© reformulÃ©

On dispose dâ€™une **liste de joueurs**, chaque joueur Ã©tant reprÃ©sentÃ© par un **tuple** :

```haskell
(nom, score)
```

On doit :

1. **extractPlayers** : extraire uniquement les noms des joueurs
2. **sortByScore** : trier les joueurs par **score dÃ©croissant**
3. **topThree** : retourner les **trois meilleurs joueurs**
4. **getTopThreePlayers** : composer les fonctions prÃ©cÃ©dentes

---

# ğŸ§  Rappels Haskell importants

* Un **tuple** : `(nom, score)`
* Une **liste** : `[(String, Int)]`
* `map` : applique une fonction Ã  chaque Ã©lÃ©ment
* `sortBy` : trie une liste avec un critÃ¨re
* `take n` : prend les `n` premiers Ã©lÃ©ments
* `(.)` : **composition de fonctions**

---

# âœ… Solution complÃ¨te en Haskell

```haskell
import Data.List (sortBy)
import Data.Ord (comparing)

-- 1ï¸âƒ£ Extraire les noms des joueurs
extractPlayers :: [(String, Int)] -> [String]
extractPlayers joueurs = map fst joueurs

-- 2ï¸âƒ£ Trier les joueurs par score dÃ©croissant
sortByScore :: [(String, Int)] -> [(String, Int)]
sortByScore joueurs = sortBy (flip (comparing snd)) joueurs

-- 3ï¸âƒ£ Prendre les trois meilleurs joueurs
topThree :: [(String, Int)] -> [(String, Int)]
topThree joueurs = take 3 joueurs

-- 4ï¸âƒ£ Composition des fonctions
getTopThreePlayers :: [(String, Int)] -> [String]
getTopThreePlayers =
    extractPlayers . topThree . sortByScore

-- Fonction principale
main :: IO ()
main = do
    let joueurs =
            [ ("Ali", 15)
            , ("Binta", 25)
            , ("Charles", 18)
            , ("Dina", 30)
            , ("Eric", 22)
            ]

    putStrLn "Les trois meilleurs joueurs sont :"
    print (getTopThreePlayers joueurs)
```

---

# ğŸ§¾ Explication dÃ©taillÃ©e (correction)

---

## 1ï¸âƒ£ Fonction `extractPlayers`

```haskell
extractPlayers :: [(String, Int)] -> [String]
extractPlayers joueurs = map fst joueurs
```

### ğŸ” Explication

* EntrÃ©e : liste de tuples `(nom, score)`
* `fst` rÃ©cupÃ¨re le **premier Ã©lÃ©ment du tuple**
* `map fst` applique `fst` Ã  chaque joueur
* RÃ©sultat : liste des **noms uniquement**

ğŸ“Œ Exemple :

```haskell
[("Ali",15),("Binta",25)] â†’ ["Ali","Binta"]
```

---

## 2ï¸âƒ£ Fonction `sortByScore`

```haskell
sortByScore :: [(String, Int)] -> [(String, Int)]
sortByScore joueurs = sortBy (flip (comparing snd)) joueurs
```

### ğŸ” Explication

* `snd` rÃ©cupÃ¨re le **score**
* `comparing snd` compare les scores
* `flip` inverse lâ€™ordre pour avoir un **tri dÃ©croissant**
* `sortBy` effectue le tri

ğŸ“Œ RÃ©sultat : du **meilleur score au plus faible**

---

## 3ï¸âƒ£ Fonction `topThree`

```haskell
topThree :: [(String, Int)] -> [(String, Int)]
topThree joueurs = take 3 joueurs
```

### ğŸ” Explication

* `take 3` prend les **trois premiers Ã©lÃ©ments**
* On suppose que la liste est dÃ©jÃ  triÃ©e

---

## 4ï¸âƒ£ Fonction composÃ©e `getTopThreePlayers`

```haskell
getTopThreePlayers :: [(String, Int)] -> [String]
getTopThreePlayers =
    extractPlayers . topThree . sortByScore
```

### ğŸ” Explication (point clÃ© de lâ€™exercice)

La composition se lit **de droite Ã  gauche** :

1. `sortByScore` â†’ trie les joueurs
2. `topThree` â†’ garde les 3 meilleurs
3. `extractPlayers` â†’ extrait les noms

ğŸ“Œ Ã‰criture Ã©quivalente (non composÃ©e) :

```haskell
getTopThreePlayers joueurs =
    extractPlayers (topThree (sortByScore joueurs))
```

---

## 5ï¸âƒ£ Fonction `main`

```haskell
main :: IO ()
main = do
```

* Point dâ€™entrÃ©e du programme
* Permet lâ€™affichage

---

## 6ï¸âƒ£ DonnÃ©es de test

```haskell
let joueurs =
    [ ("Ali", 15)
    , ("Binta", 25)
    , ("Charles", 18)
    , ("Dina", 30)
    , ("Eric", 22)
    ]
```

---

## 7ï¸âƒ£ Affichage du rÃ©sultat

```haskell
print (getTopThreePlayers joueurs)
```

### ğŸ“¤ RÃ©sultat affichÃ© :

```text
["Dina","Binta","Eric"]
```

---

# âœ… Ce que le correcteur attend

âœ”ï¸ Utilisation correcte des tuples
âœ”ï¸ Tri dÃ©croissant
âœ”ï¸ Bonne extraction des noms
âœ”ï¸ Bonne **composition de fonctions**
âœ”ï¸ PrÃ©sence de `main`

---

